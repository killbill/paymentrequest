//
// Simple Bitcoin Payment Protocol messages
//
// Use fields 100+ for extensions;
// to avoid conflicts, register extensions at:
// https://en.bitcoin.it/wiki/Payment_Request
//

package payments;
option java_package = "org.bitcoin.protocols.payments";
option java_outer_classname = "Protos";

// Generalized form of "send payment to this/these bitcoin addresses"
message Output {
        optional uint64 amount = 1 [default = 0]; // amount is integer-number-of-satoshis
        required bytes script = 2; // usually one of the standard Script forms
}
message PaymentDetails {
        optional string network = 1 [default = "main"];                    // "main" or "test"
        repeated Output outputs = 2;                                       // Where payment should be sent
        required uint64 time = 3;                                          // Timestamp; when payment request created
        optional uint64 expires = 4;                                       // Timestamp; when this request should be considered invalid
        optional string memo = 5;                                          // Human-readable description of request for the customer
        optional string payment_url = 6;                                   // URL to send Payment and get PaymentACK
        optional bytes merchant_data = 7;                                  // Arbitrary data to include in the Payment message
        optional bytes serialized_recurring_payment_details = 8;           // RecurringPaymentDetails
}
message PaymentRequest {
        optional uint32 payment_details_version = 1 [default = 1];
        optional string pki_type = 2 [default = "none"];  // none / x509+sha256 / x509+sha1
        optional bytes pki_data = 3;                      // depends on pki_type
        required bytes serialized_payment_details = 4;    // PaymentDetails
        optional bytes signature = 5;                     // pki-dependent signature
}
message X509Certificates {
        repeated bytes certificate = 1;    // DER-encoded X.509 certificate chain
}
message Payment {
        optional bytes merchant_data = 1;  // From PaymentDetails.merchant_data
        repeated bytes transactions = 2;   // Signed transactions that satisfy PaymentDetails.outputs
        repeated Output refund_to = 3;     // Where to send refunds, if a refund is necessary
        optional string memo = 4;          // Human-readable message for the merchant
}
message PaymentACK {
        required Payment payment = 1;      // Payment message that triggered this ACK
        optional string memo = 2;          // human-readable message for customer
}
enum PaymentFrequencyType {
        WEEKLY = 1;
        MONTHLY = 2;
        QUARTERLY = 3;
        ANNUAL = 4;
}
message RecurringPaymentDetails {
        required string merchant_id = 1;                 // Namespace for the merchant such as org.foo.bar
        required bytes subscription_id = 2;              // Id for the recurring subscription
        repeated RecurringPaymentContract contracts = 3; // Contracts associated with a given subscription
}
message RecurringPaymentContract {
        required bytes contract_id = 1;                           // Unique id for a given contract
        required string polling_url = 2;                          // URL to poll to get the next PaymentRequest
        required uint64 starts = 3;                               // Timestamp; when this contract starts
        optional uint64 ends = 4;                                 // Timestamp; when this contract should be considered invalid
        optional PaymentFrequencyType payment_frequency_type = 5; // Expected payment frequency
        optional uint64 max_payment_per_period  = 6;              // Max payment amount within that frequency (e.g. no more than 5 BTC per month)
        optional uint64 max_payment_amount = 7;                   // Max payment amount (e.g. no more than 3 BTC per payment)
}
